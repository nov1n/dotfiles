#!/usr/bin/env bash

set -euo pipefail

VERSION="0.0.1"
DEFAULT_MODEL="gemini-2.5-flash"

show_keybindings() {
  cat <<EOF
(Enter)      Run the suggested command
(e)xplain    Get an explanation of the command
(r)efine     Refine the command with additional requirements
(c)opy       Copy command to clipboard
(q)uit       Exit without running
(h)elp / ?   Show this help
EOF
}

show_help() {
  cat <<EOF
? - AI-powered bash command generation tool

Usage: ? [OPTIONS] <prompt>

Options:
    -m <model>      Model to use (default: $DEFAULT_MODEL)
    -d, --debug     Print debug information
    -h, --help      Show this help message
    -v, --version   Show version

Keybindings:
EOF
  show_keybindings | sed 's/^/    /'
  cat <<EOF

Examples:
    ? kill all node processes
    ? "compress this directory excluding node_modules"
    ? list all files in \$HOME not owned by \$(whoami)

Tip: Add an alias to your ~/.{bash,zsh,...}rc for convenience:
    alias '?'='ai_cmd'

EOF
}

show_version() {
  echo "? version $VERSION"
}

check_dependencies() {
  if ! command -v gemini &>/dev/null; then
    echo "Error: gemini CLI is not installed"
    echo "Install it from: https://github.com/google-gemini/gemini-cli"
    exit 1
  fi

  if [ -z "${GEMINI_API_KEY:-}" ]; then
    echo "Error: Gemini API key not configured" >&2
    echo "Set GEMINI_API_KEY environment variable" >&2
    echo "Get your API key from: https://aistudio.google.com/app/apikey" >&2
    exit 1
  fi
}

show_spinner() {
  local pid=$1
  local delay=0.1
  local spinstr='|/-\'
  local i=0

  while kill -0 "$pid" 2>/dev/null; do
    local char="${spinstr:i++%${#spinstr}:1}"
    printf "\r%s " "$char" >&2
    sleep $delay
  done
  printf "\r  \r" >&2
}

build_base_prompt() {
  local prompt="$1"

  echo "You are a command-line expert. Your ONLY job is to provide a single runnable shell command.

CRITICAL RULES:
- Return ONLY the command itself - nothing else
- NO explanations, NO markdown, NO code blocks, NO tool calls
- Do NOT say you cannot do something - just provide the shell command
- The command will be executed directly in a bash shell
- ALWAYS prefer the simplest, most basic command that accomplishes the task
- MUST be a single line command - no multi-line scripts, loops, or functions

Shell best practices:
- ALWAYS quote strings that contain spaces (e.g., echo \"hello world\" NOT echo hello world)
- Quote all literal strings to prevent word splitting
- Use proper escaping for special characters
- Avoid unnecessary flags unless specifically requested

User request: $prompt"
}

call_gemini() {
  local full_prompt="$1"
  local model="$2"

  if [ "${DEBUG:-false}" = "true" ]; then
    echo "=== DEBUG: Full prompt ===" >&2
    echo "$full_prompt" >&2
    echo "=== END DEBUG ===" >&2
    echo >&2
  fi

  local response
  local temp_stderr
  local temp_stdout
  temp_stderr=$(mktemp)
  temp_stdout=$(mktemp)

  gemini -m "$model" -o text -p "$full_prompt" 2>"$temp_stderr" >"$temp_stdout" &
  local gemini_pid=$!

  show_spinner $gemini_pid
  wait $gemini_pid
  local exit_code=$?

  response=$(cat "$temp_stdout")

  if [ $exit_code -ne 0 ] || [ -z "$response" ]; then
    if [ -s "$temp_stderr" ]; then
      cat "$temp_stderr" >&2
    else
      echo "Error: Failed to get response from Gemini" >&2
    fi
    rm -f "$temp_stderr" "$temp_stdout"
    return 1
  fi

  rm -f "$temp_stderr" "$temp_stdout"

  echo "$response" | grep -v "^gemini:" | sed 's/```.*//g' | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

generate_command() {
  local prompt="$1"
  local model="${2:-$DEFAULT_MODEL}"

  local full_prompt
  full_prompt=$(build_base_prompt "$prompt")

  call_gemini "$full_prompt" "$model"
}

refine_command() {
  local prompt="$1"
  local model="$2"
  local accumulated_context="$3"
  local last_cmd="$4"

  local full_prompt
  full_prompt=$(build_base_prompt "$prompt")

  full_prompt="$full_prompt

The previous command was: $last_cmd

Modify this command to satisfy ALL of these requirements:
$accumulated_context

IMPORTANT: Keep the existing command structure but add or modify flags to satisfy the new requirements. Make sure the command actually does what is requested."

  call_gemini "$full_prompt" "$model"
}

show_menu() {
  local cmd="$1"

  echo "$ $cmd"
}

get_action() {
  local choice
  local result

  read -r -s -n 1 choice

  case "$choice" in
    "")
      result="run"
      ;;
    e | E)
      result="explain"
      ;;
    r | R)
      result="refine"
      ;;
    c | C)
      result="copy"
      ;;
    q | Q | $'\e')
      result="quit"
      ;;
    h | H | \?)
      result="help"
      ;;
    *)
      result="invalid"
      ;;
  esac

  echo "$result"
}

execute_command() {
  local cmd="$1"

  # Add to shell history
  if [ -n "${ZSH_VERSION:-}" ]; then
    print -s "$cmd"
  elif [ -n "${BASH_VERSION:-}" ]; then
    history -s "$cmd"
  fi

  eval "$cmd"
}

copy_command() {
  local cmd="$1"

  if command -v pbcopy &>/dev/null; then
    printf "%s" "$cmd" | pbcopy
    echo "Copied to clipboard"
  elif command -v xclip &>/dev/null; then
    printf "%s" "$cmd" | xclip -selection clipboard
    echo "Copied to clipboard"
  else
    echo "Clipboard tool not found. Command:"
    echo "$cmd"
  fi
}

explain_command() {
  local cmd="$1"
  local model="${2:-$DEFAULT_MODEL}"

  echo "Getting explanation..."
  echo

  local explain_prompt="Explain this shell command in a clear and concise way:

$cmd

Format as plain text for terminal display. Use section headers like 'Overview:', 'Flags:', 'Notes:' without numbering or special characters. Keep it conversational and easy to read."

  local temp_stderr
  local temp_stdout
  temp_stderr=$(mktemp)
  temp_stdout=$(mktemp)

  gemini -m "$model" -o text -p "$explain_prompt" 2>"$temp_stderr" >"$temp_stdout" &
  local gemini_pid=$!

  show_spinner $gemini_pid
  wait $gemini_pid
  local exit_code=$?

  if [ $exit_code -ne 0 ]; then
    if [ -s "$temp_stderr" ]; then
      cat "$temp_stderr" >&2
    else
      echo "Error: Failed to get explanation from Gemini" >&2
    fi
    rm -f "$temp_stderr" "$temp_stdout"
    return 1
  fi

  cat "$temp_stdout"
  rm -f "$temp_stderr" "$temp_stdout"
  echo
}

main() {
  local prompt=""
  local model="$DEFAULT_MODEL"
  export DEBUG="false"

  while [[ $# -gt 0 ]]; do
    case $1 in
      -m)
        if [ -z "${2:-}" ]; then
          echo "Error: -m flag requires a model name"
          show_help
          exit 1
        fi
        model="$2"
        shift 2
        ;;
      -d | --debug)
        export DEBUG="true"
        shift
        ;;
      -h | --help)
        show_help
        exit 0
        ;;
      -v | --version)
        show_version
        exit 0
        ;;
      -*)
        echo "Unknown option: $1"
        show_help
        exit 1
        ;;
      *)
        prompt="$*"
        break
        ;;
    esac
  done

  if [ -z "$prompt" ]; then
    show_help
    exit 1
  fi

  check_dependencies

  local accumulated_context=""

  local command

  if ! command=$(generate_command "$prompt" "$model"); then
    echo "Error: Failed to generate command"
    exit 1
  fi

  if [ -z "$command" ]; then
    echo "Error: No command received"
    exit 1
  fi

  while true; do
    show_menu "$command"

    local action
    action=$(get_action)

    case "$action" in
      run)
        execute_command "$command"
        break
        ;;
      explain)
        echo
        explain_command "$command" "$model"
        ;;
      refine)
        echo
        echo -n "Refine: "
        read -r context_input
        echo

        if [ -z "$context_input" ]; then
          echo "Refinement cannot be empty"
          echo
          continue
        fi

        local context_to_add="- $context_input"

        if [ -z "$accumulated_context" ]; then
          accumulated_context="$context_to_add"
        else
          accumulated_context="$accumulated_context"$'\n'"$context_to_add"
        fi

        if ! command=$(refine_command "$prompt" "$model" "$accumulated_context" "$command"); then
          echo "Error: Failed to refine command"
          exit 1
        fi

        if [ -z "$command" ]; then
          echo "Error: No refined command received"
          exit 1
        fi
        continue
        ;;

      copy)
        echo
        copy_command "$command"
        break
        ;;
      help)
        echo
        echo "Keybindings:"
        show_keybindings | sed 's/^/  /'
        echo
        ;;
      quit)
        echo
        echo "Quitting..."
        exit 0
        ;;
      invalid)
        printf "\033[2K\r"
        echo "Invalid input. Please try again."
        echo
        ;;
    esac
  done
}

main "$@"
