#!/usr/bin/env bash

set -euo pipefail

VERSION="0.0.1"
DEFAULT_MODEL="gemini-2.5-flash"

show_keybindings() {
  cat <<EOF
(Enter)      Run the generated command
(e)xplain    Get an explanation of the command
(r)efine     Refine the command with additional requirements
(c)opy       Copy command to clipboard
(q)uit       Exit without running
(h)elp / ?   Show this help
EOF
}

show_help() {
  cat <<EOF
? - AI-powered command generation tool
Usage: ? [OPTIONS] <prompt>

Options:

    -m <model>      Gemini model to use (default: $DEFAULT_MODEL)
                    Note: Only Gemini models are supported
    -d, --debug     Print debug information
    -q, --quiet     Suppress shell integration warning
    -h, --help      Show this help message
    -v, --version   Show version
    --init <shell>  Output shell integration code (bash or zsh)

Keybindings:
EOF
  show_keybindings | sed 's/^/    /'
  cat <<EOF

Examples (quotes are optional):
    ? kill all node processes
    ? "compress this directory excluding node_modules"
    ? list all files in \$HOME not owned by \$(whoami)
EOF
}

show_version() {
  echo "? version $VERSION"
}

show_init() {
  local shell="${1:-}"

  if [ -z "$shell" ]; then
    echo "Error: --init requires a shell argument (bash or zsh)" >&2
    echo "Usage: ai_cmd --init bash|zsh" >&2
    return 1
  fi

  case "$shell" in
    zsh)
      cat <<'EOF'
'?' () {
  local tmpfile=$(mktemp)
  AI_CMD_WRAPPER=1 ai_cmd "$@" 2>&1 | tee "$tmpfile"

  local cmd=$(tr -d '\r' < "$tmpfile" | \grep -o '$ .*' | tail -1 | cut -c 3-)

  [[ -n "$cmd" ]] && print -s "$cmd"

  rm -f "$tmpfile"
}
alias '?'='noglob ?'
EOF
      ;;
    bash)
      cat <<'EOF'
function ? {
  # Add the prompt to the history as bash doesn't record function calls by default
  history -s "? $*"

  local tmpfile=$(mktemp)
  AI_CMD_WRAPPER=1 ai_cmd "$@" 2>&1 | tee "$tmpfile"

  local cmd=$(tr -d '\r' < "$tmpfile" | \grep -o '$ .*' | tail -1 | cut -c 3-)

  [[ -n "$cmd" ]] && history -s "$cmd"

  rm -f "$tmpfile"
}
EOF
      ;;
    *)
      echo "Error: Unsupported shell '$shell'. Use 'bash' or 'zsh'." >&2
      return 1
      ;;
  esac
}

check_preconditions() {
  if ! command -v gemini &>/dev/null; then
    echo "Error: gemini CLI is not installed"
    echo "Install it from: https://github.com/google-gemini/gemini-cli"
    exit 1
  fi

  # Check if gemini is configured by looking for the config directory
  if [ ! -d "$HOME/.gemini" ]; then
    echo "Looks like this is your first run!" >&2
    echo "" >&2
    echo "To set up authentication, run:" >&2
    echo "" >&2
    echo "  gemini" >&2
    echo "" >&2
    echo "Then choose 'Login with Google' to set up OAuth authentication." >&2
    echo "This includes a free tier of 60 requests/min and 1,000 requests/day." >&2
    echo "Finally, type /exit and run this script again" >&2
    exit 1
  fi
}

show_spinner() {
  local pid=$1
  local delay=0.1
  local spinstr="|/-\\"
  local i=0

  while kill -0 "$pid" 2>/dev/null; do
    local char="${spinstr:i++%${#spinstr}:1}"
    printf "\r%s " "$char" >&2
    sleep $delay
  done
  printf "\r  \r" >&2
}

build_base_prompt() {
  local prompt="$1"

  cat <<EOF
Generate a shell command for this task. Output only the raw command text, no formatting or explanation.

Examples:
"list files modified today" → find . -type f -mtime 0
"count python lines" → find . -name "*.py" -exec wc -l {} + | tail -1
"show tcp listeners" → lsof -iTCP -sTCP:LISTEN

Task: $prompt
EOF
}

call_gemini() {
  local full_prompt="$1"
  local model="$2"

  if [ "${DEBUG:-false}" = "true" ]; then
    echo "=== DEBUG: Full prompt ===" >&2
    echo "$full_prompt" >&2
    echo "=== END DEBUG ===" >&2
    echo >&2
  fi

  local response
  local temp_stderr
  local temp_stdout
  temp_stderr=$(mktemp)
  temp_stdout=$(mktemp)

  gemini -m "$model" "$full_prompt" 2>"$temp_stderr" >"$temp_stdout" &
  local gemini_pid=$!

  show_spinner $gemini_pid
  wait $gemini_pid
  local exit_code=$?

  response=$(cat "$temp_stdout")

  if [ $exit_code -ne 0 ] || [ -z "$response" ]; then
    if [ -s "$temp_stderr" ]; then
      cat "$temp_stderr" >&2
    else
      echo "Error: Failed to get response from Gemini" >&2
    fi
    rm -f "$temp_stderr" "$temp_stdout"
    return 1
  fi

  rm -f "$temp_stderr" "$temp_stdout"

  echo "$response" | grep -v "^gemini:" | sed 's/```.*//g' | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

generate_command() {
  local prompt="$1"
  local model="${2:-$DEFAULT_MODEL}"

  local full_prompt
  full_prompt=$(build_base_prompt "$prompt")

  call_gemini "$full_prompt" "$model"
}

refine_command() {
  local prompt="$1"
  local model="$2"
  local accumulated_context="$3"
  local last_cmd="$4"

  local full_prompt
  full_prompt=$(build_base_prompt "$prompt")

  full_prompt="$full_prompt

The previous command was: $last_cmd

Modify this command to satisfy ALL of these requirements:
$accumulated_context

IMPORTANT: Keep the existing command structure but add or modify flags to satisfy the new requirements. Make sure the command actually does what is requested."

  call_gemini "$full_prompt" "$model"
}

show_menu() {
  local cmd="$1"

  echo "$ $cmd"
}

get_action() {
  local choice
  local result

  read -r -s -n 1 choice

  case "$choice" in
    "")
      result="run"
      ;;
    e | E)
      result="explain"
      ;;
    r | R)
      result="refine"
      ;;
    c | C)
      result="copy"
      ;;
    q | Q | $'\e')
      result="quit"
      ;;
    h | H | \?)
      result="help"
      ;;
    *)
      result="invalid"
      ;;
  esac

  echo "$result"
}

execute_command() {
  local cmd="$1"

  # Add to shell history
  if [ -n "${ZSH_VERSION:-}" ]; then
    print -s "$cmd"
  elif [ -n "${BASH_VERSION:-}" ]; then
    history -s "$cmd"
  fi

  eval "$cmd"
}

copy_command() {
  local cmd="$1"

  if command -v pbcopy &>/dev/null; then
    printf "%s" "$cmd" | pbcopy
    echo "Copied to clipboard"
  elif command -v xclip &>/dev/null; then
    printf "%s" "$cmd" | xclip -selection clipboard
    echo "Copied to clipboard"
  else
    echo "Clipboard tool not found. Command:"
    echo "$cmd"
  fi
}

explain_command() {
  local cmd="$1"
  local model="${2:-$DEFAULT_MODEL}"

  echo "Explaining..."
  echo

  local explain_prompt="Explain this shell command in a clear and concise way:

$cmd

Format as plain text for terminal display. Use section headers like 'Overview:', 'Flags:', 'Notes:' without numbering or special characters. Keep it conversational and easy to read."

  local temp_stderr
  local temp_stdout
  temp_stderr=$(mktemp)
  temp_stdout=$(mktemp)

  gemini -m "$model" -o text -p "$explain_prompt" 2>"$temp_stderr" >"$temp_stdout" &
  local gemini_pid=$!

  show_spinner $gemini_pid
  wait $gemini_pid
  local exit_code=$?

  if [ $exit_code -ne 0 ]; then
    if [ -s "$temp_stderr" ]; then
      cat "$temp_stderr" >&2
    else
      echo "Error: Failed to get explanation from Gemini" >&2
    fi
    rm -f "$temp_stderr" "$temp_stdout"
    return 1
  fi

  cat "$temp_stdout"
  rm -f "$temp_stderr" "$temp_stdout"
  echo
}

main() {
  local prompt=""
  local model="$DEFAULT_MODEL"
  local suppress_warning="false"
  export DEBUG="false"

  while [[ $# -gt 0 ]]; do
    case $1 in
      -m)
        if [ -z "${2:-}" ]; then
          echo "Error: -m flag requires a model name"
          show_help
          exit 1
        fi
        model="$2"
        shift 2
        ;;
      -d | --debug)
        export DEBUG="true"
        shift
        ;;
      -q | --quiet)
        suppress_warning="true"
        shift
        ;;
      -h | --help)
        show_help
        exit 0
        ;;
      -v | --version)
        show_version
        exit 0
        ;;
      --init)
        if [ -z "${2:-}" ]; then
          echo "Error: --init requires a shell argument (bash or zsh)"
          show_help
          exit 1
        fi
        show_init "$2"
        exit 0
        ;;
      -*)
        echo "Unknown option: $1"
        show_help
        exit 1
        ;;
      *)
        prompt="$*"
        break
        ;;
    esac
  done

  if [ -z "$prompt" ]; then
    if [ -z "${AI_CMD_WRAPPER:-}" ] && [ "$suppress_warning" != "true" ]; then
      cat >&2 <<'EOF'
Warning: Running without shell integration. Commands won't be added to history.

Add this to your shell config:

  For zsh (~/.zshrc):
    eval "$(ai_cmd --init zsh)"

  For bash (~/.bashrc):
    eval "$(ai_cmd --init bash)"

Or use -q/--quiet to suppress this warning.

EOF
    fi
    show_help
    exit 1
  fi

  check_preconditions

  if [ -z "${AI_CMD_WRAPPER:-}" ] && [ "$suppress_warning" != "true" ]; then
    cat >&2 <<'EOF'
Warning: Running without shell integration. Commands won't be added to history.

Add this to your shell config:

  For zsh (~/.zshrc):
    eval "$(ai_cmd --init zsh)"

  For bash (~/.bashrc):
    eval "$(ai_cmd --init bash)"

Or use -q/--quiet to suppress this warning.

EOF
  fi

  local accumulated_context=""

  local command

  if ! command=$(generate_command "$prompt" "$model"); then
    echo "Error: Failed to generate command"
    exit 1
  fi

  if [ -z "$command" ]; then
    echo "Error: No command received"
    exit 1
  fi

  while true; do
    show_menu "$command"

    local action
    action=$(get_action)

    case "$action" in
      run)
        execute_command "$command"
        ;;
      explain)
        echo
        explain_command "$command" "$model"
        ;;
      refine)
        echo
        echo -n "Refine: "
        read -r context_input
        echo

        if [ -z "$context_input" ]; then
          echo "Refinement cannot be empty"
          echo
          continue
        fi

        local context_to_add="- $context_input"

        if [ -z "$accumulated_context" ]; then
          accumulated_context="$context_to_add"
        else
          accumulated_context="$accumulated_context"$'\n'"$context_to_add"
        fi

        if ! command=$(refine_command "$prompt" "$model" "$accumulated_context" "$command"); then
          echo "Error: Failed to refine command"
          exit 1
        fi

        if [ -z "$command" ]; then
          echo "Error: No refined command received"
          exit 1
        fi
        continue
        ;;

      copy)
        echo
        copy_command "$command"
        break
        ;;
      help)
        echo
        echo "Keybindings:"
        show_keybindings | sed 's/^/  /'
        echo
        ;;
      quit)
        echo
        echo "Quitting..."
        exit 0
        ;;
      invalid)
        printf "\033[2K\r"
        echo "Invalid input. Please try again."
        echo
        ;;
    esac
  done
}

main "$@"
